'From Squeak6.0 of 5 July 2022 [latest update: #22104] on 6 July 2022 at 9:04:15 am'!BookMorph subclass: #StoryboardBookMorph	instanceVariableNames: 'alansSliders panAndTiltFactor zoomFactor zoomController'	classVariableNames: ''	poolDictionaries: ''	category: 'MorphicExtras-Books'!!StoryboardBookMorph methodsFor: 'initialization' stamp: 'ct 6/16/2022 17:46' prior: 91247064!intoWorld: world	zoomController openInWorld.! !SHTextStyler subclass: #SHTextStylerST80	instanceVariableNames: 'classOrMetaClass workspace font parser formatAssignments environment sourceMap processedSourceMap pixelHeight attributesByPixelHeight parseAMethod context'	classVariableNames: 'EnforceItalicEmphasisInComments SyntaxHighlightingAsYouTypeAnsiAssignment SyntaxHighlightingAsYouTypeLeftArrowAssignment TextAttributesByPixelHeight'	poolDictionaries: ''	category: 'ShoutCore-Styling'!!SHTextStylerST80 methodsFor: 'style table' stamp: 'mt 7/3/2022 11:58' prior: 85155933!createTextAttributesForPixelHeight: aNumber	| result |	 	result := IdentityDictionary new.	result at: #default put: {}. "Required as fall-back for non-existing attributes."		self class themeProperties do: [:each |		| spec element emphasis font color |		element := each first.		spec := self userInterfaceTheme perform: element.		spec isArray ifFalse: [spec := {spec}]. "Support color-only hints."				color := spec first ifNotNil: [:colorSpec | Color colorFrom: colorSpec].		emphasis := spec at: 2 ifAbsent:[nil].		font := spec at: 3 ifAbsent: [nil].				(element == #comment and: [self class enforceItalicEmphasisInComments])			ifTrue: [				emphasis					ifNil: [emphasis := TextEmphasis italic]					ifNotNil: [						emphasis isArray							ifFalse: [emphasis := {emphasis}, {TextEmphasis italic}]							ifTrue: [emphasis := emphasis, {TextEmphasis italic}].				emphasis := emphasis asSet asArray "no double italic"]].				"Support for named text styles."		font isString ifTrue: [			| textStyle |			textStyle := TextStyle named: font.			font := textStyle ifNotNil: [textStyle fontOfSize: aNumber]].		(self createAttributeArrayForColor: color emphasis: emphasis font: font)			ifNotEmpty: [:attrArray | result at: element put: attrArray]].	^ result! !!SHTextStylerST80 commentStamp: 'tween 8/27/2004 10:55' prior: 0!I style Smalltalk methods and expressions.My 'styleTable' class instance var holds an array ofArrays which control how each token is styled/coloured. See my defaultStyleTable class method for its structure.My styleTable can be changed by either modifying the defaultStyleTable class method and then executing SHTextStylerST80 initialize ; or by giving me a new styleTable through my #styleTable: class method.My 'textAttributesByPixelSize' class instance var contains a dictionary of dictionaries.	The key is a pixelSize and the value a Dictionary from token type Symbol to TextAttribute array.	It is created/maintained automatically.	I also install these 3 preferences when my class initialize method is executed....	#syntaxHighlightingAsYouType  - controls whether methods are styled in browsers	#syntaxHighlightingAsYouTypeAnsiAssignment - controls whether assignments are formatted to be :=	#syntaxHighlightingAsYouTypeLeftArrowAssignment - controls whether assignments are formatted to be _I reimplement #unstyledTextFrom: so that TextActions are preserved in the unstyled text 					 	!SHTextStylerST80 class	instanceVariableNames: ''!!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'mt 7/3/2022 11:56'!enforceItalicEmphasisInComments	<preference: 'Enforce Italic in Comments'		categoryList: #(browsing Accessibility)		description: 'When enabled, always typeset source-code comments in italic, regardless of the current UI theme. When disabled, depend on what the current UI theme prescribes as text attributes for such comments.'		type: #Boolean>	^ EnforceItalicEmphasisInComments ifNil: [true]! !!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'mt 7/3/2022 11:50'!enforceItalicEmphasisInComments: aBooleanOrNil	EnforceItalicEmphasisInComments = aBooleanOrNil ifTrue: [^ self].	EnforceItalicEmphasisInComments := aBooleanOrNil.	self userInterfaceTheme apply. "Invalidate all styling caches."	! !Morph subclass: #SketchMorph	instanceVariableNames: 'originalForm rotationStyle scalePoint framesToDwell rotatedForm keepAspectRatio'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!SketchMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45' prior: 88092522!reduceColorPalette: evt	"Let the user ask for a reduced number of colors in this sketch"	| str nColors |	str := UIManager default		request: 'Please enter a number greater than one.(note: this cannot be undone, so answer zeroto abort if you need to make a backup first)' translated		initialAnswer: '256'.	nColors := Integer readFrom: (ReadStream on: str).	(nColors between: 2 and: 256) ifFalse: [^ self].	originalForm := originalForm copyWithColorsReducedTo: nColors.	rotatedForm := nil.	self changed! !AlignmentMorph subclass: #PluggablePanelMorph	instanceVariableNames: 'model getChildrenSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!PluggablePanelMorph methodsFor: 'update' stamp: 'ct 7/4/2022 18:39' prior: 63531534!update: selectorSymbolOrNil	selectorSymbolOrNil ifNil: [^ self].	selectorSymbolOrNil = getChildrenSelector ifTrue: [		self rebuildPaneAfter: [			| children |			children := self children.			self				 removeAllMorphs;				 addAllMorphs: children.			self containingWindow ifNotNil: [:window |				children do: [:child |					child adoptPaneColor: window paneColor]].						"Let my children take all the place unless my extent is described by them."			self hResizing ~~ #shrinkWrap ifTrue:				[self submorphsDo: [:m | m hResizing: #spaceFill]].			self vResizing ~~ #shrinkWrap ifTrue:				[self submorphsDo: [:m | m vResizing: #spaceFill]].						"Tell dependents about this update. There is no pluggable notification for changed submorphs."			self changed: #submorphs]].! !!PluggablePanelMorph methodsFor: 'private' stamp: 'ct 7/5/2022 09:25'!rebuildPaneAfter: replacePaneMorphsBlock	"Performance. Reset layout properties during children update to avoid intermediate relayouting."	| cellGap wantsGrips wantsPaneSplitters |	self flag: #duplication. "See PluggableSystemWindow>>#rebuildPaneAfter: and MorphicToolBuilder>>#buildPluggableWindow:."		cellGap := self cellGap.	wantsGrips := self wantsGrips.	wantsPaneSplitters := self wantsPaneSplitters.		self cellGap: 0.	self wantsPaneSplitters: false; wantsGrips: false.	self removePaneSplitters; removeGrips.		^ replacePaneMorphsBlock ensure: [		wantsPaneSplitters ifTrue: [			self wantsPaneSplitters: wantsPaneSplitters.			self addPaneSplitters].		wantsGrips ifTrue: [			self wantsGrips: wantsGrips.			self addGrips].		self cellGap: cellGap]! !PluggableTextMorph class	instanceVariableNames: ''!!PluggableTextMorph class methodsFor: 'preferences' stamp: 'mt 7/4/2022 17:54' prior: 63708005!applyUserInterfaceTheme	self flushAdornmentCache.	TextEditor withAllSubclassesDo: [:cls |		cls initializeYellowButtonMenu.		cls initializeShiftedYellowButtonMenu].! !Morph subclass: #DialogWindow	instanceVariableNames: 'titleMorph messageMorph paneMorph buttonRow result selectedButton cancelButton timeout preferredPosition keyMap exclusive filter filterEnabled filterMorph autoCancel'	classVariableNames: 'GradientDialog IncludeCloseButton IncludeControlMenu RoundedDialogCorners UseWiggleAnimation'	poolDictionaries: ''	category: 'Morphic-Windows'!!DialogWindow methodsFor: 'initialization' stamp: 'mt 7/4/2022 18:09' prior: 26125052!setMessageParameters	| fontToUse colorToUse margins |	messageMorph ifNil: [^ self].	fontToUse := self userInterfaceTheme font ifNil: [TextStyle defaultFont].	colorToUse := self userInterfaceTheme textColor ifNil: [Color black].	margins := (TextStyle pointsToPixels: 5) truncated.	messageMorph		margins: (self wantsRoundedCorners			ifTrue: [margins @ (margins - self cornerRadius) corner: margins @ margins]			ifFalse: [margins]);		textColor: colorToUse;		textStyle: fontToUse asNewTextStyle. "Use style with other point sizes available"			"Style read-only text for copy interaction."	self flag: #todo. "mt: Duplication with PluggableTextMorph >> #setDefaultParameters"	(UserInterfaceTheme current get: #caretColor for: #PluggableTextMorph)		ifNotNil: [:c | messageMorph caretColor: c].	(UserInterfaceTheme current get: #selectionColor for: #PluggableTextMorph)		ifNotNil: [:c | 			self userInterfaceTheme color = (UserInterfaceTheme current get: #color for: #PluggableTextMorph)				ifTrue: [messageMorph selectionColor: c]				ifFalse: [					"Background is different than in a text field. Use dialog-title color to ensure contrast."					messageMorph selectionColor: self userInterfaceTheme titleColor]].! !SystemWindow subclass: #PluggableSystemWindow	instanceVariableNames: 'getLabelSelector getChildrenSelector closeWindowSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!PluggableSystemWindow methodsFor: 'updating' stamp: 'ct 7/4/2022 18:54' prior: 63554011!update: what	what ifNil:[^self].	what == getLabelSelector ifTrue:[self setLabel: (model perform: getLabelSelector)].	what == getChildrenSelector ifTrue: [		self rebuildPaneAfter: [			paneMorphs ifNil: [paneMorphs := #()].			self removeAllMorphsIn: paneMorphs.			paneMorphs := model perform: getChildrenSelector.			self addAllMorphs: paneMorphs.			paneMorphs do: [:child |				child adoptPaneColor: self paneColor].			paneMorphs do: [:m | m hResizing: #spaceFill; vResizing: #spaceFill]]].	what == #windowColorToUse ifTrue: [		self paneColor = model windowColorToUse ifFalse:			[self refreshWindowColor]].	^super update: what! !!PluggableSystemWindow methodsFor: 'private' stamp: 'ct 7/5/2022 09:25'!rebuildPaneAfter: replacePaneMorphsBlock	"Performance. Reset layout properties during children update to avoid intermediate relayouting."	| cellGap wantsGrips wantsPaneSplitters |	self flag: #duplication. "See PluggablePanelMorph>>#rebuildPaneAfter: and MorphicToolBuilder>>#buildPluggableWindow:."		cellGap := self cellGap.	wantsGrips := self wantsGrips.	wantsPaneSplitters := self wantsPaneSplitters.		self cellGap: 0.	self wantsPaneSplitters: false; wantsGrips: false.	self removePaneSplitters; removeGrips.		^ replacePaneMorphsBlock ensure: [		wantsPaneSplitters ifTrue: [			self wantsPaneSplitters: wantsPaneSplitters.			self addPaneSplitters].		wantsGrips ifTrue: [			self wantsGrips: wantsGrips.			self addGrips].		self cellGap: cellGap]! !!PluggableSystemWindow commentStamp: 'ar 2/11/2005 20:14' prior: 0!A pluggable system window. Fixes the issues with label retrieval and adds support for changing children.!ToolBuilder subclass: #MorphicToolBuilder	instanceVariableNames: 'widgets panes parentMenu'	classVariableNames: 'ButtonBorderWidth ButtonMargins ListBorderWidth ListMargins TextBorderWidth TextMargins'	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!MorphicToolBuilder methodsFor: 'widgets required' stamp: 'ct 7/4/2022 18:45' prior: 58453963!buildPluggablePanel: aSpec	| widget |	widget := self panelClass new.	self register: widget id: aSpec name.	widget model: aSpec model.	"Set child dependent layout properties."	self setLayoutHintsFor: widget spec: aSpec.	widget layoutInset: (aSpec padding ifNil: [self panelPadding]).	widget wantsPaneSplitters: (aSpec wantsResizeHandles ifNil: [false]).	"widget wantsGrips: true."	widget cellGap: (aSpec spacing ifNil: [		widget wantsPaneSplitters			ifTrue: [self windowSpacing]			ifFalse: [self panelSpacing]]).		"Now create the children."	aSpec children isSymbol		ifTrue: [			widget getChildrenSelector: aSpec children.			widget update: widget getChildrenSelector]		ifFalse: [			widget rebuildPaneAfter: [				self buildAll: aSpec children in: widget]].		self setFrame: aSpec frame in: widget.	self setLayout: aSpec layout in: widget.		parent ifNotNil:[self add: widget to: parent].	widget borderWidth: 0.	self buildHelpFor: widget spec: aSpec. 	widget color: Color transparent.		^ widget! !!MorphicToolBuilder methodsFor: 'widgets required' stamp: 'ct 7/4/2022 18:39' prior: 58515854!buildPluggableWindow: aSpec	| widget |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec) new.	self register: widget id: aSpec name.		widget model: aSpec model.	"Set child dependent layout properties."	MorphicProject worldGridEnabled ifTrue: [		"Snap both #position and #extent to grid."		aSpec horizontalResizing ifNil: [aSpec horizontalResizing: #spaceFill].		aSpec verticalResizing ifNil: [aSpec verticalResizing: #spaceFill]].			self setLayoutHintsFor: widget spec: aSpec.	widget layoutInset: (aSpec padding ifNil: [self windowPadding]).	widget morphicLayerNumber: widget class windowLayer.		self flag: #todo. "ct: Below, there is a lot of duplication with #buildPluggablePanel:. Can we factor out some of this, or even just collect all children in a PluggablePanelMorph?"	widget cellGap: (aSpec spacing ifNil: [self windowSpacing]).	widget wantsGrips: true.	widget wantsPaneSplitters: (aSpec wantsResizeHandles ifNil: [true]).		"Now create the children."	panes := OrderedCollection new.	aSpec children isSymbol		ifTrue: [			widget getChildrenSelector: aSpec children.			widget update: aSpec children]		ifFalse: [			widget rebuildPaneAfter: [				self buildAll: aSpec children in: widget]].	widget setUpdatablePanesFrom: panes.	aSpec defaultFocus ifNotNil: [:name |		widget defaultFocusMorph: name].		aSpec label ifNotNil: [:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	widget closeWindowSelector: aSpec closeAction.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: ((aSpec extent ifNil:[widget initialExtent]) * RealEstateAgent windowScaleFactor * RealEstateAgent scaleFactor) rounded		world: self currentWorld).	widget refreshWindowColor.	^ widget! !TerseGuideHelp class	instanceVariableNames: ''!!TerseGuideHelp class methodsFor: 'pages' stamp: 'mt 7/4/2022 09:32' prior: 98475106!block	"This method was automatically generated. Edit it using:"	"TerseGuideHelp edit: #block"	<generated>	^(HelpTopic		title: 'Blocks'		contents: '"Blocks: - blocks are objects and may be assigned to a variable - value is last expression evaluated unless explicit return - blocks may be nested - specification -         [ arguments | | localvars | expressions ] - ^ expression terminates block & method (exits all nested blocks) - blocks intended for long term storage should not contain ^,	as they can not return to the sender context - use #cull: (and #cull:cull:...) if you do not know the exact number of arguments - blocks (along with polymorphism on booleans) are the basis of control structures	-> See Conditional Expressions"| x y z fac |x := [ y := 1. z := 2. ]. x value.							"simple block usage"x := [ :argOne :argTwo |   argOne, '' and '' , argTwo.].	"set up block with argument passing"Transcript show: (x value: ''First'' value: ''Second''); cr.	"use block with argument passing"x := [:e | | v | v := 1. e + v] value: 2.					"local variable in a block"fac := [ :n | n > 1 ifTrue:  [n * (fac value: n-1)] ifFalse: [1]].	"closure on block variable"fac value: 5.											"closure variable scoped to its block"!!' readStream nextChunkText)			key: #block;			shouldStyle: true;			yourself! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'mt 7/4/2022 09:26'!conditionalExpression	"This method was automatically generated. Edit it using:"	"TerseGuideHelp edit: #conditionalExpression"	<generated>	^(HelpTopic		title: 'Conditional Expression'		contents: '"Conditional Expressions: - Conditional expressions, or control structures in general, use	blocks as deferred computations which can be evaluated	selectively"| x switch result |x := 11.x > 10 ifTrue: [Transcript show: ''ifTrue''; cr].		"if then"x > 10 ifFalse: [Transcript show: ''ifFalse''; cr].	"if else"x > 10											"if then else"   ifTrue: [Transcript show: ''ifTrue''; cr]   ifFalse: [Transcript show: ''ifFalse''; cr].x > 10											"if else then"   ifFalse: [Transcript show: ''ifFalse''; cr]   ifTrue: [Transcript show: ''ifTrue''; cr].Transcript   show:      (x > 10         ifTrue: [''ifTrue'']         ifFalse: [''ifFalse'']);   cr.Transcript										"nested if then else"   show:      (x > 10         ifTrue: [x > 5            ifTrue: [''A'']            ifFalse: [''B'']]         ifFalse: [''C'']);   cr.switch := Dictionary new.						"switch functionality"switch at: $A put: [Transcript show: ''Case A''; cr].switch at: $B put: [Transcript show: ''Case B''; cr].switch at: $C put: [Transcript show: ''Case C''; cr].result := (switch at: $B) value.!!' readStream nextChunkText)			key: #conditionalExpression;			shouldStyle: true;			yourself! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'mt 7/4/2022 09:25' prior: 98579526!pages	^ #( introduction transcript assignment constants boolean arithmetic		bitwise conversion block exceptionHandling methodCall conditionalExpression		iterationStatement character string symbol  array orderedCollection		sortedCollection bag set interval association dictionary internalStream		fileStream date time point rectangle pen dynamic metaclass debugging		misc )! !ReleaseBuilder class	instanceVariableNames: ''!!ReleaseBuilder class methodsFor: 'class initialization' stamp: 'mt 7/2/2022 11:38' prior: 84068758!initialize	QAndA ifNil: [self clearQAndA].	"We have to be after AutoStart so that Morphic is up and running."	Smalltalk addToStartUpList: ReleaseBuilder after: AutoStart.	SystemVersion newVersion: 'Squeak6.0'! !Object subclass: #SystemVersion	instanceVariableNames: 'version date highestUpdate updates'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'System-Support'!!SystemVersion methodsFor: 'continuous integration' stamp: 'mt 7/4/2022 17:29' prior: 97443498!ciStatusPageUrl	^ 'https://github.com/squeak-smalltalk/squeak-app/actions/workflows/{1}?query=branch%3A{2}{3}{4}'		format: {			self ciWorkflow.			self ciBranch.			'+is%3Acompleted'. "Show only completed runs."			self isRelease				ifTrue: ['' "Only Trunk has daily builds"]				ifFalse: ['+event%3Aschedule']}! !!SystemVersion methodsFor: 'continuous integration' stamp: 'mt 7/4/2022 10:12' prior: 97446315!ciStatusTimestamp	"Slow. Fetch HTML page, extract first occurrence of		... <time-ago datetime='2021-08-04T14:24:20Z' ... "	| statusResponse statusPage begin end dateAndTime |	statusResponse := WebClient httpGet: self ciStatusPageUrl.	statusResponse isSuccess ifFalse: [^ nil].	statusPage := statusResponse content.	begin := statusPage findString: 'datetime' startingAt: 100000. "Skip the first X bytes decoration."	begin = 0 ifTrue: [^ nil].	end := statusPage findString: 'Z' startingAt: begin.	end = 0 ifTrue: [^ nil].	dateAndTime := DateAndTime readFrom: (statusPage copyFrom: begin + 10 to: end) readStream.	^ String streamContents: [:s |		dateAndTime asDate = Date today			ifTrue: [s nextPutAll: 'Today' translated, ',']			ifFalse: [dateAndTime asDate = Date yesterday				ifTrue: [s nextPutAll: 'Yesterday' translated, ',']				ifFalse: [dateAndTime printYMDOn: s]].		s space.		dateAndTime printHMOn: s]! !Object subclass: #MCMcmUpdater	instanceVariableNames: 'repository updateMapName lastUpdateMap'	classVariableNames: 'DefaultUpdateMap DefaultUpdateURL Registry SkipPackages UpdateFromServerAtStartup UpdateMissingPackages'	poolDictionaries: ''	category: 'MonticelloConfigurations'!!MCMcmUpdater methodsFor: 'accessing' stamp: 'mt 7/2/2022 11:17'!lastUpdateMapAt: repoDescription		^ self lastUpdateMap		at: repoDescription		ifAbsent: [			self lastUpdateMap				at: (self class alternativeDescriptionOf: repoDescription)				ifAbsent: [0]]! !!MCMcmUpdater methodsFor: 'accessing' stamp: 'mt 7/2/2022 11:19'!lastUpdateMapAt: repoDescription put: lastUpdate		self lastUpdateMap at: repoDescription put: lastUpdate.	self lastUpdateMap at: (self class alternativeDescriptionOf: repoDescription) put: lastUpdate.! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:00' prior: 53029764!refreshUpdateMapFor: r with: updateList	"Update the lastUpdateMap and answer a possibly reduced updateList"	| config |	(self lastUpdateMapAt: r description) = 0 ifTrue: [		"No update has ever been loaded from this repo. If no package is		present in the image either, we can skip right to the latest config"		config := r versionNamed: updateList last value.		(config dependencies anySatisfy: [:dep | dep package hasWorkingCopy])			ifFalse: [(self useLatestPackagesFrom: r)					ifTrue: [self lastUpdateMapAt: r description put: updateList last key].				updateList isEmpty					ifTrue: [^ #()]					ifFalse: [^ updateList last: 1]]].	^ updateList! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:01' prior: 53032870!updateFromRepository	| config repo |	repo := self getRepositoryFromRepositoryGroup.	repo cacheAllFileNamesDuring: [ | updateList |		updateList := self updateListFor: repo.		"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			updateList := self refreshUpdateMapFor: repo with: updateList.			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: ('Processing {1}' translated format: {assoc value}).				config := repo versionNamed: assoc value.				self updateFromConfig: config.				self lastUpdateMapAt: repo description put: assoc key.			] displayingProgress: 'Processing configurations' translated.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			(self useLatestPackagesFrom: repo) ifTrue: [				config updateFromRepositories.				config upgrade].		]].	^ config! !!MCMcmUpdater methodsFor: 'updating' stamp: 'mt 7/2/2022 11:01' prior: 53034943!updateFromRepository: repository upTo: versionNumber	| config |	config := nil.	repository cacheAllFileNamesDuring: [ | updateList |		updateList := self updateListFor: repository.		"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			updateList := self refreshUpdateMapFor: repository with: updateList.			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				assoc key > versionNumber ifTrue: [^config].				ProgressNotification signal: '' extra: ('Processing ' translated format: {assoc value}).				config := repository versionNamed: assoc value.				self updateFromConfig: config.				self lastUpdateMapAt: repository description put: assoc key.			] displayingProgress: 'Processing configurations' translated.		]].	^config! !!MCMcmUpdater methodsFor: 'private' stamp: 'mt 7/2/2022 11:01' prior: 53038788!updateListFor: repo	| updateList allNames minVersion |	updateList := OrderedCollection new.	minVersion := self lastUpdateMapAt: repo description.	"Find all the update-*.mcm files"	allNames := ('Checking {1}' translated format: {repo description})		displayProgressFrom: 0 to: 1 during: [:bar| 			bar value: 0.			repo allFileNamesOrCache ].	allNames do: [:fileName | | version |		((fileName endsWith: '.mcm')			and: [fileName packageAndBranchName = self updateMapName				and: [(version := fileName versionNumber) >= minVersion]]) 					ifTrue: [updateList add: version -> fileName]].	^updateList sort! !MCMcmUpdater class	instanceVariableNames: ''!!MCMcmUpdater class methodsFor: 'registry' stamp: 'mt 7/2/2022 11:17' prior: 53068296!forRepository: repository updateMap: basename	"Answer the requested updater from the repository, or nil of not found"	"MCMcmUpdater forRepository: 'http://source.squeak.org/trunk' updateMap: 'update'"	"MCMcmUpdater forRepository: 'foo' updateMap: 'bar'"	^ ((Registry ifNil: [Registry := Dictionary new])		at: repository		ifAbsent: [Registry at: (self alternativeDescriptionOf: repository) ifAbsent: [^nil]])			at: basename			ifAbsent: [^nil]! !!MCMcmUpdater class methodsFor: 'utilities' stamp: 'mt 7/2/2022 11:16'!alternativeDescriptionOf: repoDescription	"Treat HTTP and HTTPS as the same repository."	(repoDescription beginsWith: 'http:')		ifTrue: [^ 'https', (repoDescription allButFirst: 4)].	(repoDescription beginsWith: 'https:')		ifTrue: [^ 'http', (repoDescription allButFirst: 5)].	^ repoDescription! !----SNAPSHOT----{6 July 2022 . 9:04:15 am} Squeak.image priorSource: 25347!----QUIT----{6 July 2022 . 9:04:16 am} Squeak.image priorSource: 25347!